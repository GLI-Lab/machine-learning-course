---
title: "Lab 01 - Numpy Basics"
jupyter: python3
---

## 목표

- NumPy 배열 생성, shape, dtype 다루기
- **Vectorization**: 반복문 대신 배열 연산으로 빠르게 계산하기
- **Broadcasting**: 서로 다른 shape의 배열이 연산될 때의 규칙 이해하기

---

## 1. 배열 생성 및 속성

```{python}
import numpy as np
```

```{python}
# 1차원 배열
a = np.array([1, 2, 3, 4, 5])
print("a =", a)
print("shape:", a.shape, "  dtype:", a.dtype)
```

```{python}
# 2차원 배열 (행렬)
B = np.array([[1, 2], [3, 4], [5, 6]])
print("B =\n", B)
print("shape:", B.shape)  # (행 개수, 열 개수)
```

```{python}
# 자주 쓰는 생성 함수
print(np.zeros(5))
print(np.ones((2, 3)))
print(np.arange(0, 10, 2))   # start, stop(미포함), step
print(np.linspace(0, 1, 5)) # 구간을 균등 분할
```

---

## 2. 인덱싱과 슬라이싱

```{python}
x = np.array([10, 20, 30, 40, 50])
print(x[0], x[-1])      # 첫 원소, 마지막 원소
print(x[1:4])           # 인덱스 1, 2, 3
print(x[::2])            # 처음부터 끝까지 2칸씩
```

```{python}
M = np.arange(12).reshape(3, 4)
print("M =\n", M)
print("M[1, 2] =", M[1, 2])
print("2행 전체:", M[2, :])
print("3열 전체:", M[:, 3])
```

---

## 3. Vectorization (벡터화)

반복문 대신 배열 전체에 한 번에 연산을 적용하면 빠르고 코드도 짧아진다.

```{python}
# 비벡터화: for 루프
def sum_squares_loop(arr):
    total = 0
    for x in arr:
        total += x ** 2
    return total

# 벡터화: 배열 연산
def sum_squares_vec(arr):
    return (arr ** 2).sum()
```

```{python}
large = np.random.randn(100_000)
%timeit sum_squares_loop(large)
%timeit sum_squares_vec(large)
```

```{python}
# 예: 시그모이드 σ(z) = 1 / (1 + exp(-z))
def sigmoid(z):
    return 1 / (1 + np.exp(-z))

z = np.linspace(-5, 5, 11)
print("z     =", z)
print("sigmoid(z) =", sigmoid(z))
```

---

## 4. Broadcasting

shape가 다른 배열끼리 연산할 때, NumPy가 자동으로 확장하는 규칙.

- **규칙**: 차원을 뒤에서부터 맞춘다. 한쪽이 1이면 그 차원을 늘려서 맞춘다.
- 예: `(3, 4)` + `(4,)` → `(4,)`를 `(1, 4)`로 보고 → `(3, 4)`와 맞춤.

```{python}
# (3, 4) + (4,) → 각 행에 같은 [1,2,3,4]가 더해짐
A = np.arange(12).reshape(3, 4)
b = np.array([1, 2, 3, 4])
print("A =\n", A)
print("b =", b)
print("A + b =\n", A + b)
```

```{python}
# (3, 4) + (3, 1) → 각 열에 같은 열 벡터가 더해짐
c = np.array([[10], [20], [30]])
print("c =\n", c)
print("A + c =\n", A + c)
```

```{python}
# 정규화: 각 행을 그 행의 합으로 나누기 (broadcasting 활용)
row_sums = A.sum(axis=1, keepdims=True)  # shape (3, 1)
print("row_sums =\n", row_sums)
normalized = A / row_sums
print("행 합이 1이 되도록:\n", normalized)
print("각 행 합:", normalized.sum(axis=1))
```

---

## 5. 연습

벡터 `v`와 각 행이 `v`와 같은 행렬 `M` (shape `(4, 3)`)을 만드세요.  
(힌트: `np.tile` 또는 broadcasting을 이용할 수 있다.)

```{python}
v = np.array([1, 2, 3])
# M = ???  # shape (4, 3), 각 행이 [1,2,3]
# print(M)
```

```{python}
# 풀이 예시 1: tile
M1 = np.tile(v, (4, 1))
print("tile:\n", M1)

# 풀이 예시 2: broadcasting
M2 = v + np.zeros((4, 3))
print("broadcasting:\n", M2)
```

---

## 참고

- ML에서 데이터는 보통 `(샘플 수, 특성 수)` shape의 2차원 배열로 다룬다.
- Gradient, loss 계산 등은 벡터화·브로드캐스팅을 쓰면 구현이 단순해지고 속도도 빨라진다.
