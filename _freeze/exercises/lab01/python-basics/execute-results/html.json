{
  "hash": "ea9ee823d58839bd90d95607f98b1ca5",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Lab 01 - Python Basics for Machine Learning\" \njupyter: python3\n---\n\n\n[![](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/GLI-Lab/machine-learning-course/blob/students/exercises/lab01/python-basics.ipynb)\n\n## Objectives\n\n* Understand core Python data structures: **Lists** and **Dictionaries**.\n* **Functions and Control Flow**: Learn how to write modular, reusable logic for data processing.\n* **List Comprehensions**: Grasp the \"Pythonic\" way to create and filter lists efficiently.\n* **Classes and Objects**: Get introduced to the basics of Object-Oriented Programming (OOP), which is crucial for defining neural networks.\n\n::: {.callout-note}\n\n## Basic Concept: Why Python for Machine Learning?\n\nPython is the lingua franca of modern Machine Learning. While standard Python is not fast enough for heavy matrix mathematics (which is why we use C-optimized libraries like NumPy or PyTorch), its clean syntax and massive ecosystem make it the perfect \"glue\" language. We rely on plain Python to load configurations, clean text data, build data loading pipelines, and orchestrate complex model training loops.\n:::\n\n## 1. Core Data Structures: Lists and Dictionaries\n\nBefore we get to matrices, we need to know how standard Python stores sequences and key-value pairs.\n\n::: {#a08a01cc .cell execution_count=1}\n``` {.python .cell-code}\n# Lists: Ordered, mutable sequences\n# Often used to store file paths, feature names, or a sequence of transformations.\nfeatures = ['age', 'income', 'height', 'weight']\nprint(\"Original features:\", features)\n\n# Appending and accessing\nfeatures.append('blood_pressure')\nprint(\"First feature:\", features[0])\nprint(\"Last feature:\", features[-1])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOriginal features: ['age', 'income', 'height', 'weight']\nFirst feature: age\nLast feature: blood_pressure\n```\n:::\n:::\n\n\n::: {#7a00e1d2 .cell execution_count=2}\n``` {.python .cell-code}\n# Dictionaries: Unordered key-value pairs (Hash Maps)\n# Essential for storing model hyperparameters or configurations.\nhyperparameters = {\n    'learning_rate': 0.001,\n    'batch_size': 32,\n    'optimizer': 'Adam'\n}\n\nprint(\"Current Learning Rate:\", hyperparameters['learning_rate'])\n\n# Adding a new key-value pair\nhyperparameters['epochs'] = 50\nprint(\"Updated Config:\", hyperparameters)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCurrent Learning Rate: 0.001\nUpdated Config: {'learning_rate': 0.001, 'batch_size': 32, 'optimizer': 'Adam', 'epochs': 50}\n```\n:::\n:::\n\n\n::: {.callout-warning}\n\n## Caveat: Lists are Slow for Math\n\nStandard Python lists can hold elements of different data types (e.g., `[1, \"hello\", 3.14]`). Because of this flexibility, Python must check the type of each element during iteration, making mathematical operations on standard lists extremely slow compared to NumPy arrays.\n:::\n\n## 2. Functions and Control Flow\n\nMachine learning workflows require modular code. We use functions to isolate tasks like data cleaning, metric calculation, or model evaluation.\n\n::: {#dc559bf8 .cell execution_count=3}\n``` {.python .cell-code}\ndef categorize_age(age):\n    \"\"\"A simple function using control flow to categorize numerical data.\"\"\"\n    if age < 18:\n        return 'Minor'\n    elif age < 65:\n        return 'Adult'\n    else:\n        return 'Senior'\n\n# Testing the function\nages = [15, 34, 72]\nfor a in ages:\n    print(f\"Age {a} is categorized as: {categorize_age(a)}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAge 15 is categorized as: Minor\nAge 34 is categorized as: Adult\nAge 72 is categorized as: Senior\n```\n:::\n:::\n\n\n## 3. List Comprehensions\n\nList comprehensions provide a concise, readable, and often faster way to create lists compared to standard `for` loops. They are ubiquitous in Python data pipelines.\n\n::: {#0e476450 .cell execution_count=4}\n``` {.python .cell-code}\n# Non-comprehension approach: Standard loop\nraw_text = [\"  Hello \", \"WORLD  \", \" machine learning\"]\nclean_text_loop = []\nfor word in raw_text:\n    clean_text_loop.append(word.strip().lower())\n\nprint(\"Cleaned with loop:\", clean_text_loop)\n\n# Pythonic approach: List Comprehension\nclean_text_comp = [word.strip().lower() for word in raw_text]\nprint(\"Cleaned with comprehension:\", clean_text_comp)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCleaned with loop: ['hello', 'world', 'machine learning']\nCleaned with comprehension: ['hello', 'world', 'machine learning']\n```\n:::\n:::\n\n\nYou can also add conditional logic (filtering) inside a comprehension:\n\n::: {#caae7009 .cell execution_count=5}\n``` {.python .cell-code}\n# Extract only the positive numbers\nnumbers = [-5, 2, -1, 10, 8]\npositives = [n for n in numbers if n > 0]\nprint(\"Positive numbers only:\", positives)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPositive numbers only: [2, 10, 8]\n```\n:::\n:::\n\n\n## 4. Basics of Classes (OOP)\n\nIn modern deep learning frameworks like PyTorch, you define your neural networks by writing a Python `class`. Understanding how to initialize a class and define its methods is strictly required.\n\n::: {#725a3215 .cell execution_count=6}\n``` {.python .cell-code}\nclass SimpleScaler:\n    \"\"\"A mock object mimicking a data scaler (like in scikit-learn).\"\"\"\n    \n    # The __init__ method runs when you create a new instance\n    def __init__(self, scale_factor):\n        self.scale_factor = scale_factor  # Store data inside the object\n        \n    # A method belonging to the class\n    def transform(self, data):\n        return [x * self.scale_factor for x in data]\n\n# Instantiate the object\nscaler = SimpleScaler(scale_factor=0.5)\n\n# Use the object's method\nraw_data = [10, 20, 30]\nscaled_data = scaler.transform(raw_data)\nprint(\"Scaled data:\", scaled_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nScaled data: [5.0, 10.0, 15.0]\n```\n:::\n:::\n\n\n## 5. Exercises\n\nYou are given a list of dictionaries representing a tiny dataset of students and their test scores.\nWrite a list comprehension that extracts the names of students who scored **higher than 80**.\n\n::: {#b713fdb8 .cell execution_count=7}\n``` {.python .cell-code}\nstudents = [\n    {'name': 'Alice', 'score': 85},\n    {'name': 'Bob', 'score': 72},\n    {'name': 'Charlie', 'score': 90},\n    {'name': 'Diana', 'score': 65}\n]\n\n# top_students = ???\n# print(top_students)\n```\n:::\n\n\n**Solutions:**\n\n::: {#2b112b45 .cell execution_count=8}\n``` {.python .cell-code}\n# Solution using list comprehension with a condition\ntop_students = [student['name'] for student in students if student['score'] > 80]\nprint(\"Students with score > 80:\", top_students)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nStudents with score > 80: ['Alice', 'Charlie']\n```\n:::\n:::\n\n\n## Summary for Machine Learning\n\n* Use **Dictionaries** to manage hyperparameters and configuration settings cleanly.\n* Master **List Comprehensions**; you will use them constantly for parsing text, filtering file paths, and formatting raw input data before feeding it into NumPy or pandas.\n* **Classes** are the building blocks of Deep Learning frameworks. You will use `__init__` to define your network layers and class methods to define how data passes through them.\n\n",
    "supporting": [
      "python-basics_files"
    ],
    "filters": [],
    "includes": {}
  }
}