{
  "hash": "397810bf05a1a70304f62d526a898ca8",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Lab 01 - Numpy Basics\"\njupyter: python3\n---\n\n\n\n\n\n## 목표\n\n- NumPy 배열 생성, shape, dtype 다루기\n- **Vectorization**: 반복문 대신 배열 연산으로 빠르게 계산하기\n- **Broadcasting**: 서로 다른 shape의 배열이 연산될 때의 규칙 이해하기\n\n---\n\n## 1. 배열 생성 및 속성\n\n::: {#493da002 .cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\n```\n:::\n\n\n::: {#d4206655 .cell execution_count=2}\n``` {.python .cell-code}\n# 1차원 배열\na = np.array([1, 2, 3, 4, 5])\nprint(\"a =\", a)\nprint(\"shape:\", a.shape, \"  dtype:\", a.dtype)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na = [1 2 3 4 5]\nshape: (5,)   dtype: int64\n```\n:::\n:::\n\n\n::: {#eb230dd9 .cell execution_count=3}\n``` {.python .cell-code}\n# 2차원 배열 (행렬)\nB = np.array([[1, 2], [3, 4], [5, 6]])\nprint(\"B =\\n\", B)\nprint(\"shape:\", B.shape)  # (행 개수, 열 개수)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nB =\n [[1 2]\n [3 4]\n [5 6]]\nshape: (3, 2)\n```\n:::\n:::\n\n\n::: {#1a17895c .cell execution_count=4}\n``` {.python .cell-code}\n# 자주 쓰는 생성 함수\nprint(np.zeros(5))\nprint(np.ones((2, 3)))\nprint(np.arange(0, 10, 2))   # start, stop(미포함), step\nprint(np.linspace(0, 1, 5)) # 구간을 균등 분할\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0. 0. 0. 0. 0.]\n[[1. 1. 1.]\n [1. 1. 1.]]\n[0 2 4 6 8]\n[0.   0.25 0.5  0.75 1.  ]\n```\n:::\n:::\n\n\n---\n\n## 2. 인덱싱과 슬라이싱\n\n::: {#fc7657ef .cell execution_count=5}\n``` {.python .cell-code}\nx = np.array([10, 20, 30, 40, 50])\nprint(x[0], x[-1])      # 첫 원소, 마지막 원소\nprint(x[1:4])           # 인덱스 1, 2, 3\nprint(x[::2])            # 처음부터 끝까지 2칸씩\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n10 50\n[20 30 40]\n[10 30 50]\n```\n:::\n:::\n\n\n::: {#a542366c .cell execution_count=6}\n``` {.python .cell-code}\nM = np.arange(12).reshape(3, 4)\nprint(\"M =\\n\", M)\nprint(\"M[1, 2] =\", M[1, 2])\nprint(\"2행 전체:\", M[2, :])\nprint(\"3열 전체:\", M[:, 3])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nM =\n [[ 0  1  2  3]\n [ 4  5  6  7]\n [ 8  9 10 11]]\nM[1, 2] = 6\n2행 전체: [ 8  9 10 11]\n3열 전체: [ 3  7 11]\n```\n:::\n:::\n\n\n---\n\n## 3. Vectorization (벡터화)\n\n반복문 대신 배열 전체에 한 번에 연산을 적용하면 빠르고 코드도 짧아진다.\n\n::: {#c84995b6 .cell execution_count=7}\n``` {.python .cell-code}\n# 비벡터화: for 루프\ndef sum_squares_loop(arr):\n    total = 0\n    for x in arr:\n        total += x ** 2\n    return total\n\n# 벡터화: 배열 연산\ndef sum_squares_vec(arr):\n    return (arr ** 2).sum()\n```\n:::\n\n\n::: {#b28f625f .cell execution_count=8}\n``` {.python .cell-code}\nlarge = np.random.randn(100_000)\n%timeit sum_squares_loop(large)\n%timeit sum_squares_vec(large)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n8.76 ms ± 165 μs per loop (mean ± std. dev. of 7 runs, 100 loops each)\n24.3 μs ± 98.5 ns per loop (mean ± std. dev. of 7 runs, 10,000 loops each)\n```\n:::\n:::\n\n\n::: {#5ba8b59a .cell execution_count=9}\n``` {.python .cell-code}\n# 예: 시그모이드 σ(z) = 1 / (1 + exp(-z))\ndef sigmoid(z):\n    return 1 / (1 + np.exp(-z))\n\nz = np.linspace(-5, 5, 11)\nprint(\"z     =\", z)\nprint(\"sigmoid(z) =\", sigmoid(z))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nz     = [-5. -4. -3. -2. -1.  0.  1.  2.  3.  4.  5.]\nsigmoid(z) = [0.00669285 0.01798621 0.04742587 0.11920292 0.26894142 0.5\n 0.73105858 0.88079708 0.95257413 0.98201379 0.99330715]\n```\n:::\n:::\n\n\n---\n\n## 4. Broadcasting\n\nshape가 다른 배열끼리 연산할 때, NumPy가 자동으로 확장하는 규칙.\n\n- **규칙**: 차원을 뒤에서부터 맞춘다. 한쪽이 1이면 그 차원을 늘려서 맞춘다.\n- 예: `(3, 4)` + `(4,)` → `(4,)`를 `(1, 4)`로 보고 → `(3, 4)`와 맞춤.\n\n::: {#ca68986b .cell execution_count=10}\n``` {.python .cell-code}\n# (3, 4) + (4,) → 각 행에 같은 [1,2,3,4]가 더해짐\nA = np.arange(12).reshape(3, 4)\nb = np.array([1, 2, 3, 4])\nprint(\"A =\\n\", A)\nprint(\"b =\", b)\nprint(\"A + b =\\n\", A + b)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nA =\n [[ 0  1  2  3]\n [ 4  5  6  7]\n [ 8  9 10 11]]\nb = [1 2 3 4]\nA + b =\n [[ 1  3  5  7]\n [ 5  7  9 11]\n [ 9 11 13 15]]\n```\n:::\n:::\n\n\n::: {#47d79e25 .cell execution_count=11}\n``` {.python .cell-code}\n# (3, 4) + (3, 1) → 각 열에 같은 열 벡터가 더해짐\nc = np.array([[10], [20], [30]])\nprint(\"c =\\n\", c)\nprint(\"A + c =\\n\", A + c)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nc =\n [[10]\n [20]\n [30]]\nA + c =\n [[10 11 12 13]\n [24 25 26 27]\n [38 39 40 41]]\n```\n:::\n:::\n\n\n::: {#a4427499 .cell execution_count=12}\n``` {.python .cell-code}\n# 정규화: 각 행을 그 행의 합으로 나누기 (broadcasting 활용)\nrow_sums = A.sum(axis=1, keepdims=True)  # shape (3, 1)\nprint(\"row_sums =\\n\", row_sums)\nnormalized = A / row_sums\nprint(\"행 합이 1이 되도록:\\n\", normalized)\nprint(\"각 행 합:\", normalized.sum(axis=1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nrow_sums =\n [[ 6]\n [22]\n [38]]\n행 합이 1이 되도록:\n [[0.         0.16666667 0.33333333 0.5       ]\n [0.18181818 0.22727273 0.27272727 0.31818182]\n [0.21052632 0.23684211 0.26315789 0.28947368]]\n각 행 합: [1. 1. 1.]\n```\n:::\n:::\n\n\n---\n\n## 5. 연습\n\n벡터 `v`와 각 행이 `v`와 같은 행렬 `M` (shape `(4, 3)`)을 만드세요.  \n(힌트: `np.tile` 또는 broadcasting을 이용할 수 있다.)\n\n::: {#975db643 .cell execution_count=13}\n``` {.python .cell-code}\nv = np.array([1, 2, 3])\n# M = ???  # shape (4, 3), 각 행이 [1,2,3]\n# print(M)\n```\n:::\n\n\n::: {#579c0818 .cell execution_count=14}\n``` {.python .cell-code}\n# 풀이 예시 1: tile\nM1 = np.tile(v, (4, 1))\nprint(\"tile:\\n\", M1)\n\n# 풀이 예시 2: broadcasting\nM2 = v + np.zeros((4, 3))\nprint(\"broadcasting:\\n\", M2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntile:\n [[1 2 3]\n [1 2 3]\n [1 2 3]\n [1 2 3]]\nbroadcasting:\n [[1. 2. 3.]\n [1. 2. 3.]\n [1. 2. 3.]\n [1. 2. 3.]]\n```\n:::\n:::\n\n\n---\n\n## 참고\n\n- ML에서 데이터는 보통 `(샘플 수, 특성 수)` shape의 2차원 배열로 다룬다.\n- Gradient, loss 계산 등은 벡터화·브로드캐스팅을 쓰면 구현이 단순해지고 속도도 빨라진다.\n\n",
    "supporting": [
      "lab01-numpy-basics_files"
    ],
    "filters": [],
    "includes": {}
  }
}